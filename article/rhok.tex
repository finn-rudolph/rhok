\documentclass[a4paper, 10pt, ngerman]{article}

\usepackage[algoruled, nosemicolon]{algorithm2e}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage[ngerman]{babel}
\usepackage[backend=biber, style=apa]{biblatex}
\usepackage[left=2.5cm, right=2.5cm, top=2.5cm, bottom=2.cm]{geometry}
\usepackage[hidelinks]{hyperref}
\usepackage[onehalfspacing]{setspace}
\usepackage{sectsty}
\usepackage[inkscapeformat=pdf]{svg}

\allsectionsfont{\sffamily}

\title{\sffamily{\textbf{Parametrisierung von Pollards Rho-Methode}}}
\author{Finn Rudolph}
\date{27.01.2024}

\addbibresource{rhok.bib}

\renewcommand{\thealgocf}{}

\newcommand{\N}{\mathbb{N}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\E}{\mathbb{E}}

\newtheorem{definition}{Definition}
\newtheorem{theorem}{Satz}

\begin{document}

\maketitle

\section*{Projektüberblick}

\tableofcontents

\section{Zusammenfassung}

\section{Motivation und Fragestellung}

Während für Rekordfaktorisierungen mittlerweile ausschließlich das Zahlkörpersieb verwendet wird, bleibt Pollards Rho-Algorithmus einer schnellsten Algorithmen zur Faktorisierung von Zahlen bis ca. $2^{64}$. Da Leistungssteigerungen bei modernen Computern häufig durch verbesserete Nebenläufigkeit (z. B. durch mehr Prozessorkerne) erzielt werden, ist es eine interessante Frage, wie Pollards Rho-Methode am besten parallel ausgeführt werden kann. Bevor die Fragestellung präzise formuliert werden kann, soll jedoch Pollards Rho-Methode erklärt werden.

\subsection{Pollards Rho-Methode}

Sei $n$ die zu faktorisierende Zahl und $f : \Z/n\Z \to \Z/n\Z$ mit $f : x \mapsto x^{2k} + 1$ für einen Parameter $1 \le k \in \N$. Man wähle einen zufälligen Anfangswert $x_0 \in \Z/n\Z$ und betrachte die Folge $(x_n)_{n \in \N}$ definiert durch $x_n = f(x_{n - 1})$ für einen Parameter $1 \le k \in \N$. Da $(x_n)_{n \in \N}$ über der endlichen Menge $\Z/n\Z$ definiert ist, ist die Folge ab einem bestimmten Punkt periodisch. Sei $p$ ein Primfaktor von $n$ und $\pi : \Z/n\Z \to \Z/p\Z$ die natürliche Projektion. Die Idee von Pollards Rho-Algorithmus ist, zwei Folgenglieder $x_i, x_j \in \Z/n\Z$ zu finden, sodass $x_i \ne x_j$ aber $\pi(x_i) = \pi(x_j)$. Dann ist nämlich $\gcd(n, x_i - x_j)$ ein echter Faktor von $n$. Nimmt man nun heuristisch an, dass die Periodenlänge von $(x_n)_{n \in \N}$ in $\Z/n\Z$ deutlich länger als die Periodenlänge in $\Z/p\Z$ ist, reicht es aus, $x_i, x_j$ mit $i \ne j$ zu finden, die kongruent modulo $p$ sind. Diese Annahme begründet sich darin, dass für den kleinsten Primfaktor $p \le \sqrt n$ gilt. Zum Finden solcher $x_i, x_j$ betrachten wir den funktionalen Graphen von $\pi(f)$, wobei $\pi(f)$ die Abbildung $f$ betrachtet in $\Z/p\Z$ ist.

\begin{definition}[Funktionaler Graph]
    Sei $X$ eine endliche Menge und $f: X \to X$ eine Abbildung. Der funktionale Graph von $f$, geschrieben $\gamma(f)$, ist der gerichtete Graph mit Knotenmenge $X$ und Kantenmenge $E$, wobei die Kante $(x, y) \in X \times X$ genau dann in $E$ liegt, wenn $f(x) = y$.
\end{definition}

\noindent Es ist leicht zu zeigen, dass jede Zusammenhangskomponente eines funktionalen Graphen aus einem Zyklus und an den Zyklusknoten gewurzelten Bäumen besteht. In $\gamma(f)$ betrachtet startet $(x_n)_{n \in \N}$ mit $x_0$ in einem Baum und "`läuft"' durch den Graphen, wobei immer die eindeutige von einem Knoten ausgehende Kante entlanggegangen wird. An der Wurzel des Baums von $x_0$ wird der Zyklus in der Zusammenhangskomponente von $x_0$ betreten, und ab genau diesem Punkt ist $(x_n)_{n \in \N}$ periodisch. Um $x_i, x_j$ mit $i \ne j$ und $\pi(x_i) = \pi(x_j)$ zu finden, wird Floyds Algorithmus zum Finden des Zyklus in der Zusammenhangskomponente von $\pi(x_0)$ in $\gamma(\pi(f))$ verwendet. Floyds Algorithmus macht sich zunutze, dass es ein $r \in \N, 1 \le r \ge 1$ mit $\pi(x_r) = \pi(x_{2r})$ geben muss. Für das minimale solcher $r$ gilt außerdem $r \le \mu(f, x_0) + \lambda(f, x_0)$, wobei $\mu(f, x_0)$ die Höhe von $x_0$ in seinem Baum und $\lambda(f, x_0)$ die Länge des Zyklus ist (\cite{knu98}, S. 7). Wir nennen $\nu(f, x_0) = \mu(f, x_0) + \lambda(f, x_0)$ die Rho-Länge von $x_0$ in $f$. Indem man die Folgen $(x_n)_{n \in \N}$ und $(x_{2n})_{n \in \N}$ gleichzeitig Glied für Glied berechnet, stößt man in maximal $\nu(f, x_0)$ Schritten auf gewünschte $x_i, x_j$. Das Überprüfen in jedem Schritt, ob $\pi(x_i) = \pi(x_{2i})$ geschieht natürlich nicht explizit, da $p$ unbekannt ist, aber implizit durch Berechnung von $\gcd(n, x_i - x_{2i})$.

\begin{algorithm*}
    $x \gets $ zufällige natürliche Zahl zwischen $0$ und $n - 1$ \;
    $y \gets x$ \;
    \While{\emph{\sc{true}}}
    {
        $x \gets x^{2k} + 1 \mod n$ \;
        $y \gets (y^{2k} + 1)^{2k} + 1 \mod n$ \;
        $g \gets \gcd(n, x - y)$ \;
        \If{$g \ne 1 \text{\emph{\textbf{ and }}} g \ne n$}
        {
            \Return{$g$} \;
        }
    }

    \caption{Pollards Rho-Algorithmus}
\end{algorithm*}

\noindent Nun soll Pollards Rho-Algorithmus analysiert werden. Sei $\Z/p\Z^*$ die Gruppe der Einheiten in $\Z/p\Z$ und $g$ = $\gcd(p - 1, 2k)$. Man beobachte, dass $\psi : \Z/p\Z^\times \to \Z/p\Z^\times$ mit $\psi : x \mapsto x^{2k}$ ein Gruppenendomorphismus mit $[\Z/p\Z : \text{Im} f] = g$ ist. Daher haben genau $(p - 1) / g$ Knoten in $\gamma(f)$ Eingangsgrad $g$ und alle anderen Eingangsgrad 0. Knoten 1 als Einzelfall mit Eingangsgrad 1 ignorieren wir. Sei $A(n)$ die Menge der Abbildungen $\Z/n\Z \to \Z/n\Z$ und $A(n, g)$ die Teilmenge von $A(n)$, in der $(p - 1) / g$ Knoten Eingangsgrad $g$ und alle anderen Eingangsgrad 0 haben. Der Analyse der Rho-Methode liegen folgende Annhamen zugrunde:
\begin{itemize}
    \item[(A1)] Die Abbildung $f : x \mapsto x^{2k} + 1$ verhält sich bezüglich der Verteilung der Rho-Längen wie eine zufällig gewählte Abbildung aus $A(p, g)$.
    \item[(A2)] Die Abbildung $f : x \mapsto x^{2} + 1$ verhält sich bezüglich der Verteilung der Rho-Längen wie eine zufällig gewählte Abbildung aus $A(p)$.
    \item[(A3)] Die durchschnittliche Anzahl an Iterationen der while-Schleife ist $\overline \nu$, bis auf eine feste Konstante, wobei $\overline \nu$ der Mittelwert von $\nu(f, x_0)$ über alle Elemente von $A(p)$ und Startwerte $x_0 \in \Z/p\Z$ ist.
\end{itemize}
Diese Annahmen werden auch von \cite{pol75} und \cite{bp81} getroffen. Eine rigorose Analyse von Pollards Rho-Algorithmus ist nicht bekannt, die Annahmen lassen sich allerdings experimentell bestätigen. Für $k = 1$ ist damit die erwartete Anzahl an Iterationen der while-Schleife $\sqrt{\pi p / 2}$ (\cite{knu98}, S. 8). Da die Berechnung des größten gemeinsamen Teilers $O(\ln n)$ Schritte benötigt, ist die erwartete Laufzeit des Algorithmus $O(\sqrt p \ln n)$. Durch eine einfache Modifikation können die Kosten des $\gcd$ amortisiert werden, sodass sich die Laufzeit auf $O(\sqrt p)$ verringert (\cite{bre80}). Damit ist pro Iteration also nur noch die Zeit zur Berechnung der $2k$-ten Potenzen von $x$ und $y$ relevant, was durchschnittlich in $3/2 \lg 2k$ Schritten möglich ist. Mit $\lg x$ wird der Logarithmus zur Basis 2 bezeichnet. Der Faktor $3/2$ wird im Folgenden ignoriert, da er für den Vergleich verschiedener Werte für $k$ irrelevant ist.

\subsection{Parallelisierung der Rho-Methode}

Sei $M$ die Anzahl verfügbarer Maschinen. Eine "`Maschine"'  meint hier nicht zwingend einen Computer, sondern eine Ressource, auf der ein sequentielles Programm ausgeführt werden kann, was beispielsweise auch ein Prozessorthread sein kann. Die Rho-Methode lässt sich parallelisieren, indem $M$ Anfangswerte unabhängig voneinander zufällig gewählt werden und auf jeder der $M$ Maschinen Pollards Rho-Algorithmus ausgeführt wird, bis eine der Maschinen einen Faktor findet. Nun ergibt sich folgende Frage, die in dieser Arbeit behandelt werden soll: \emph{Wie wählt man den Parameter $k$ für jede Maschine optimal, um eine möglichst geringe Laufzeit zu erzielen?} Vereinfachend wird nicht die Zeit betrachtet, die Floyds Algorithmus zum Finden eines Zyklus benötigt, sondern die Zeit, bis in der Folge $(x_n)_{n \in \N}$ eine Kollision auftritt, d.h. ein Wert erneut angenommen wird, der bereits angenommen wurde. Eine Zeiteinheit ist hier die Dauer einer Iteration im Fall $k = 1$, d.h. eine Maschine mit Paramter $k$ führt in $t$ Zeiteinheiten $\lfloor t / \lg 2k \rfloor$ Iterationen aus. Eine Zuordnung von $k$-Werten für $M$ Maschinen schreiben wir als Tupel $K = (k_1, k_2, \dots, k_M), 1 \le k_i \in \N$.  Wir bezeichnen mit $L(K)$ die erwartete Laufzeit des parallelen Pollard-Rho-Algorithmus mit $k$-Werten gegeben durch $K$. Mit (A1) und (A3) gilt also
\begin{align*}
    L(K) = \E \bigg ( \min_{i = 1}^M X_i \bigg )
\end{align*}
wobei $X_i$ die gleichverteilte Zufallsvariable über $A(p, \gcd(p - 1, 2k_i)) \times \Z/p\Z$ mit $X_i(f, x_0) = \nu(f, x_0)$ ist. Eine Schwierigkeit in der Herleitung einer Formel für $L(K)$ ist, dass die Rho-Längen der $i$-ten und $j$-ten Maschine nicht unabhängig sind, wenn $k_i = k_j$, da sich die $i$-te und $j$-te Maschine in diesem Fall im gleichen funktionalen Graphen bewegen. Wenn beispielsweise der Startwert der $i$-ten Maschine fixiert wird, ist bereits klar, dass die Rho-Länge der $j$-ten Maschine größer gleich der Rho-Länge der $i$-ten Maschine sein wird, wenn der Startwert ein Vorfahre des Startwerts der $i$-ten Maschine in einem Baum von $\gamma(f)$ ist. Daher werden im Folgenden die zwei Fälle abhängiger und unabhängiger Maschinen unterschieden.

\section{Eine Formel für den Fall unabhängiger Maschinen}

In diesem Abschnitt wird eine Formel für $L(K)$ hergleitet, die im Fall paarweise verschiedener $k$-Werte gilt. Für den Fall mehrerer Maschinen wird die Annahme getroffen, dass die Rho-Längen der $i$-ten und $j$-ten Maschine als Zufallsvariablen betrachtet stochastisch unabhängig sind, wenn $k_i \ne k_j$. Denn wenn $k_i \ne k_j$ und sich $x \mapsto x^{2k_i} + 1$ und $x \mapsto x^{2k_j} + 1$ bezüglich der Rho-Länge wie zufällig gewählte Abbildung verhalten, ist es vertretbar, die Unabhängigkeit der Rho-Längen anzunehmen.

Folgendes Argument basiert auf dem von \cite{bp81}, S. 627 -- 628, angepasst für mehrere Maschinen. Es wird die die Wahrscheinlichkeit betracht, dass nach genau $t$ Zeiteinheiten erstmalig eine Kollision bei einer Maschine auftritt. Die Wahrscheinlichkeit, dass im $i$-ten Schritt zu einem Vorgänger eines bereits besuchten Knotens gegangen wird (sodass im nächsten Schritt eine Kollision stattfände), ist $i \cdot (\gcd(p - 1, 2k) - 1)/(p - 1)$. Folglich ist die Wahrscheinlichkeit, dass bei einer Maschine mit Paramter $k$ nach $t$ Zeiteinheiten noch keine Kollision aufgetreten ist
\begin{align*}
    \prod_{j = 0}^{\lfloor t / \lg 2k \rfloor} \bigg (1 - \frac {j} {p / (\gcd(p - 1, 2k) - 1)} \bigg )
\end{align*}
Wir lassen im Folgenden die Gaußklammern weg, da sie asymptotisch nichts verändern und verwenden Taylors Näherung $1 + x \approx \exp x$ für $|x|$ klein. Sei $h_i = p / (\gcd(p - 1, 2k_i) - 1)$. Da in allen praktischen Fällen $h_i$ groß und $t$ deutlich kleiner als $p$ ist, ist die Wahrscheinlichkeit, dass nach genau $t$ Zeiteinheiten die erste Kollision auftritt
\begin{align*}
    \mathbb{P}_t
     & = \prod_{i = 1}^M \prod_{j = 0}^{t / \lg k_i - 1}
    \Bigg (1 - \frac {j} {h_i} \Bigg ) \cdot \Bigg (1 - \prod_{i = 1}^M \Bigg (1 - \frac {t / \lg 2k_i} {h_i} \Bigg ) \Bigg )                                                            \\
     & \approx \prod_{i = 1}^M \prod_{j = 0}^{t / \lg k_i - 1} \exp \Bigg ( \frac {-j}{h_i} \Bigg ) \cdot \Bigg (1 - \prod_{i = 1}^M \exp \Bigg (\frac {-t}{h_i \lg 2k_i} \Bigg )\Bigg ) \\
     & = \exp \Bigg ({- \sum_{i = 1}^M \sum_{j = 0}^{t/\lg 2k_i - 1} \frac j {h_i}} \Bigg ) \cdot \Bigg (1 - \exp \Bigg ( -\sum_{i = 1}^M \frac t {h_i \lg 2k_i} \Bigg ) \Bigg )         \\
     & \approx \exp \Bigg (- \sum_{i = 1}^M \frac {(t/\lg 2k_i)(t/\lg 2k_i - 1)} {2h_i} \Bigg ) \cdot t \cdot \Bigg (\sum_{i = 1}^M \frac 1 {h_i \lg 2k_i} \Bigg )                       \\
     & \approx \exp \Bigg (- \frac {t^2} 2 \sum_{i = 1}^M \frac 1 {h_i \lg^2 2k_i} \Bigg ) \cdot t \cdot \Bigg (\sum_{i = 1}^M \frac 1 {h_i \lg 2k_i} \Bigg )
\end{align*}
Um nun eine Formel für den Erwartungswert zu erhalten, wird $\sum_{a = 1}^p t \mathbb{P}_t$ durch $\int_{0}^\infty t \mathbb{P}_t \; dt$ angenähert, was wegen der schnellen Konvergenz von $e^{-t^2} \to 0$ wenn $t \to \infty$ vertetbar ist.
\begin{align}
    L(K)
     & = \Bigg ( \sum_{i = 1}^M \frac 1 {h_i \lg 2k_i} \Bigg ) \int_{0}^{\infty} t^2 \exp \Bigg (- \frac {t^2} 2 \sum_{i = 1}^M \frac 1 {h_i \lg^2 2k_i} \Bigg ) \nonumber \\
     & = \Bigg ( \sum_{i = 1}^M \frac 1 {h_i \lg 2k_i} \Bigg ) \sqrt {\pi/2} \Bigg (\sum_{i = 1}^M \frac 1 {h_i \lg^2 2k_i} \Bigg )^{-3/2}
\end{align}
Zur Auswertung des Integrals wurde die Tabelle in Wikipedia: \cite{gint} verwendet. Auch wenn die Herleitung aufgrund der vielen Näherungen krude scheint, erklärt sie gut das Laufzeitverhalten im Fall unabhängiger Maschinen. Setzt man beispielsweise $M = 1$ und $k_1 = 1$, erhält man $\sqrt{\pi p / 2}$, wie in \cite{pol75}. Für $M = 1$ und beliebiges $k_1$ erhält man $\sqrt{\pi p / 2} \cdot \lg^2 2k_1 / \sqrt{\gcd(p-1, 2k_1) - 1}$. Daraus folgt, dass die Anzahl an Iterationen im Fall einer Maschine um einen Faktor $1/\sqrt{\gcd(p - 1, 2k) - 1}$ im Vergleich zu $k = 1$ reduziert wird. Dieses Ergebnis erhielten auch \cite{bp81}.

\section{Die erwartete Rho-Länge in zufälligen Funktionen}

Um $L(K)$ zu bestimmen, wenn $k_i = k_j$ für $i \ne j$ gilt, muss die Abhängigkeit der Rho-Längen der $i$-ten und $j$-ten Maschinen berücksichtigt werden. Denn setzt man beispielsweise $M = 2$ und $k_1 = k_2 = 1$ in (1) ein, erhält man eine erwartete Laufzeit von $\sqrt {\pi p / 4}$. In diesem Abschnitt wird allerdings gezeigt, dass unter Berücksichtigung der Abhängigkeit $25/32 \cdot \sqrt{\pi p / 2}$ Schritte benötigt werden, und letzterer Wert wird von Experimenten unterstützt. Der Fall abhängiger Maschinen hat sich als weitaus schwieriger herausgestellt und es wurde keine allgemeine Formel gefunden. Jedoch konnte der Fall $M = 2, k_1 = k_2$ gelöst werden und einige Ideen für den Fall von beliebigem $M$ und $k_1 = k_2 = \dots = k_M$ entwickelt werden. Für letzteren Fall genügt es, den Fall $k_i = 1 \; (1 \le i \le M)$ zu betrachten. Denn wie bereits angemerkt wird für eine Maschine die durchschnittliche Rho-Länge durch Veränderung von $k$ um einen Faktor $1 / \sqrt {\gcd(p - 1, 2k) - 1}$ verringert, es gilt also $L(k_1, k_2, \dots, k_M) = L(1, 1, \dots, 1) / \sqrt{\gcd(p - 1, 2k)-1}$. Mit $k_i = 1 \; (1 \le i \le M)$ reduziert sich das Problem nach (A2) auf folgende Frage: \emph{Gegeben ein zufälliges Element $f$ aus $A(p)$ und $M$ zufällige Elemente $x_{i, 0} \in Z/p\Z \; (1 \le i \le M)$, was ist der Erwartungswert von $\min_{i = 1}^M \nu(f, x_{i, 0})$?}

\subsection{Theoretischer Hintergrund: Erzeugende Funktionen}

Der grundlegende Ansatz zur Beantwortung obiger Frage für $M = 2$ ist, die Summe der minimalen Rho-Längen über alle Elemente von $A(p)$ und Paare an Anfangswerten zu bestimmen. Dafür soll eine erzeugende Funktion $\Psi(x, w)$ hergeleitet werden, in der die Variable $x$ die Größe des Graphen und die Variable $w$ die minimale Rho-Länge markiert. Dann gilt nämlich
\begin{align*}
    L(1, 1) = \frac {n!}{n^{n + 2}} [x^n] \Bigg (\frac {\partial} {\partial w} \Psi(x, w) \Bigg ) \Bigg \vert_{w = 1}
\end{align*}
wobei $[x^n]$ den $n$-ten Koeffizienten in der Reihenentwicklung des nachstehenden Terms bezeichnet.

Da funktionale Graphen beschriftet sind, werden stets erzeugende Funktionen von exponentiellem Typ (EF) verwendet. Folgende Komponenten eines funktionalen Graphen werden als Grundlage verwendet, um einen funktionalen Graphen zu konstruieren (\cite{fo90}, S. 333).
\begin{align*}
    T(x) = x \exp T(x) \quad (\text{Baum}) \qquad\qquad C(x) = \log \frac {1} {1 - x} \quad (\text{Zyklus})
\end{align*}
Ein funktionaler Graph ist nun eine Menge an Zyklen von Bäumen, also ist die EF für funktionale Graphen
\begin{align*}
    F(x) = \exp C(T(x)) = \exp \log \frac 1 {1 - T(x)} = \frac 1 {1 - T(x)}
\end{align*}

Zuletzt wird noch der Begriff einer asymptotischen Näherung benötigt. Wir nennen $f(x)$ genau dann asymptotisch zu $g(x)$ und schreiben $f(x) \sim g(x)$, wenn
\begin{align*}
    \lim_{x \to \infty} \frac {f(x)} {g(x)} = 1
\end{align*}

// Erklären warum eine asymptotische Abschätzung sinnvoll ist und wir nicht O-Notation verwenden

\subsection{Der Fall zweier Anfangswerte}

\begin{theorem}
    Sei $A(n)$ die Menge der Abbildungen $\Z/n\Z \to \Z/n\Z$. Dann gilt
    \begin{align*}
        \frac 1 {n^{n + 2}} \sum_{f \in A(n)} \; \sum_{a \in \Z/n\Z} \; \sum_{b \in \Z/n\Z} \min(\nu(f, a), \nu(f, b)) \sim \frac {25} {32} \sqrt{\pi n / 2}
    \end{align*}
\end{theorem}

\begin{proof}
    Seien $a$ und $b$ die zwei Startknoten. Zur Bestimmung von $\Psi(x, w)$ unterscheiden wir drei disjunkte Fälle. Es wird grundsätzlich angenommen, dass $\nu(f, a) \le \nu(f, b)$, und wenn $\nu(f, a) < \nu(f, b)$, wird mit einem Faktor 2 für das mögliche Vertauschen von $a$ und $b$ multipliziert.

    \begin{figure}
        \begin{tabular}{ccc}
            \includesvg[width=150pt]{pics/alpha} & \includesvg[width=150pt]{pics/beta} & \includesvg[width=150pt]{pics/gamma} \\
            ($\alpha$)                           & ($\beta$)                           & ($\gamma$)
        \end{tabular}
        \caption{Die drei Fälle für die Bestimmung von $\Psi(x, w)$. Die Kanten stellen keine einzelne Kante dar, sondern einen beliebig langen (und möglicherweise leeren) Pfad. Beispielsweise steht die gelbe Kurve in ($\alpha$) für den Zyklus in dem Zusammenhangskomponenten von $a$.}
    \end{figure}

    \textbf{Fall 1.} (\emph{$a$ und $b$ liegen in unterschiedlichen Zusammenhangskomponenten.}) Dieser Fall wird erneut in die Fälle $\lambda(f, b) \le \nu(f, a)$ und $\lambda(f, b) > \nu(f, a)$ unterteilt. Die erzeugende Funktion für den ersten Fall lautet
    \begin{align*}
        \alpha_1(x, w) = \frac {x^2w(1 + x^2w)} {(1 - x^2w)^3} \cdot \Bigg (1 + \frac {2x} {1 - x} \Bigg ) = \frac {x^2w(1 + x)(1 + x^2w)} {(1 - x^2w)^3(1 - x)}
    \end{align*}
    In diesem Fall ist es möglich, zuerst zwei $\rho$-Graphen mit gleicher Größe zu erzeugen und anschließend den Pfad von $b$ zu seinem Zyklus zu verlängern. Ein $\rho$-Graph ist ein Zusammenhangskomponent in Abbildung ($\alpha$), d.h. ein Zyklus mit einem Pfad anhängend. Es gibt genau $n! \cdot n$ $\rho$-Graphen mit $n$ Knoten, da es für jede Permutation der Knoten $n$ Möglichkeiten für die Größe des Zyklus gibt. Folglich gibt es für gerade $n$ genau $n! \cdot n^2/2$ Paare an $\rho$-Graphen, die beide $n/2$ Knoten besitzen. Die erzeugende Funktion von Paaren an $\rho$-Graphen ist also
    \begin{align*}
        \sum_{n = 0}^\infty x^n \cdot \frac {n^2} 4 \cdot \frac {1 + (-1)^n} 2 = \frac {x^2(1 + x^2)} {(1 - x^2)^3}
    \end{align*}
    Um die halbe Anzahl an Knoten mit $w$ zu markieren, ersetze man $x$ durch $x \sqrt w$ und erhält $x^2w(1 + x^2w) / (1 - x^2w)^3$. Damit ist der erste Faktor in $\alpha_1(x, w)$ geklärt. Nun gibt es zwei Möglichkeiten: Wird der Pfad von $b$ zu seinem Zyklus nicht verlängert, gilt $\nu(f, a) = \nu(f, b)$, es gibt also genau eine Möglichkeit. Wird hingegen ein Pfad von Länge $\ge 1$, dessen erzeugende Funktion $x/(1 - x)$ ist angehängt, ergeben sich zwei Möglichkeiten durch Vertauschung von $a$ und $b$.

    Im zweiten Fall ist die erzeugende Funktion
    \begin{align*}
        \alpha_2(x, w) = 2 \cdot \frac {x^2w} {(1 - x^2w)^2} \cdot  \frac x {1 - x} \cdot \frac {1}{1 - x} = \frac {2x^3w} {(1 - x^2w)^2 (1 - x)^2}
    \end{align*}
    Der Faktor $x^2w$ repräsentiert die zwei Knoten, an denen $a$ und $b$ jeweils ihren Zyklus betreten, und der Knoten von $a$ ist mit $w$ markiert. Mit $1 / (1 - x^2w)^2$ erhält man zwei Pfade, von denen jeweils eine Kopie angefertigt wird und die Länge mit $w$ markiert wird. Im Komponenten von $a$ werden diese zwei Pfade für den gelben und violetten Teil in Abbildung 1 ($\alpha$) verwendet. Damit ist der Exponent von $w$ genau die Rho-Länge von $a$. Der Zyklus von $b$ besteht aus den zwei Kopien der Pfade und einem Pfad von Länge $\ge 1$, sodass $\lambda(f, b) > \nu(f, a)$ sichergestellt ist. Der übrige $1 / (1 - x)$-Term steht für den Pfad von $b$ zum Zyklus.

    Die erzeugende Funktion für Fall 1 ist also
    \begin{align*}
        \alpha(x, w) = \alpha_1(x, w) + \alpha_2(x, w) = \frac {x^2w(1 + 2x - x^2 + x^2w - 2x^3w - x^4w)} {(1 - x^2w)^3(1 - x)^2}
    \end{align*}

    \textbf{Fall 2.} (\emph{$a$ und $b$ liegen im gleichen Baum und ihr kleinster gemeinsamer Vorfahre ist nicht die Wurzel.}) Anders formuliert: Betrachtet man die Pfade, die $a$ und $b$ durch wiederholtes Anwenden von $f$ in $\gamma(f)$ ablaufen, treffen diese sich nicht erstmals in einem Zyklusknoten. Die erzeugende Funktion lautet
    \begin{align*}
        \beta(x, w) = xw \cdot \frac {xw} {1 - xw} \cdot \frac {1} {1 - xw} \cdot \frac {1} {1 - x^2w} \cdot \Bigg (1 + \frac {2x} {1 - x} \Bigg ) = \frac {x^2w^2} {(1 - xw)^2(1 - x^2w)} \Bigg (1 + \frac {2x} {1 - x} \Bigg )
    \end{align*}
    Der Zyklusknoten, an dem der Baum von $a$ und $b$ anhängt, wird durch $xw$ repräsentiert. Der in Abbildung 1 ($\beta$) pinkfarbene Pfad muss mindestens Länge 1 haben, da der kleinste gemeinsame Vorfahre von $a$ und $b$ sonst die Wurzel wäre, was den Faktor $xw/(1 - xw)$ erklärt. Der Faktor $1/(1 - xw)$ steht für den Zyklus. Mit $1/(1 - x^2w)$ werden zwei gleich lange Pfade erzeugt, von denen einer mit $w$ markiert wird. Der $w$-markierte Pfad führt von $a$ zum kleinsten gemeinsamen Vorfahren, und der andere Pfad ist ein Teil des Pfads vom kleinsten gemeinsamen Vorfahren zu $b$. Nun gibt es wie in Fall 1 wieder die Option, den Pfad von $b$ zum kleinsten gemeinsamen Vorfahren echt zu verlängern, und so einen Faktor 2 für die mögliche Vertauschung von $a$ und $b$ zu erhalten, oder ihn zu lassen, wobei es wegen Symmetrie nur eine Möglichkeit gibt.

    \textbf{Fall 3.} (\emph{$a$ und $b$ liegen in verschiedenen Bäumen oder die Wurzel ist kleinster gemeinsamer Vorfahre.})
\end{proof}

\subsection{Mögliche Methoden für den allgemeinen Fall}

\section{Bestimmung optimaler Exponenten für die Rho-Methode}

\subsection{Der Fall einer Maschine}

\subsection{Der Fall zweier Maschinen}

\section{Experimentelle Ergebnisse}\label{sec:ex}

\section{Fazit}

\printbibliography

\end{document}