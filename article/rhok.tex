\documentclass[a4paper, 10pt, ngerman]{article}

\usepackage[algoruled, nosemicolon]{algorithm2e}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage[ngerman]{babel}
\usepackage[backend=biber, style=apa]{biblatex}
\usepackage[left=2.5cm, right=2.5cm, top=2.5cm, bottom=2.cm]{geometry}
\usepackage[hidelinks]{hyperref}
\usepackage[onehalfspacing]{setspace}
\usepackage{sectsty}

\allsectionsfont{\sffamily}

\title{\sffamily{\textbf{Parametrisierung von Pollards Rho-Methode}}}
\author{Finn Rudolph}
\date{27.01.2024}

\addbibresource{rhok.bib}

\renewcommand{\thealgocf}{}

\newcommand{\N}{\mathbb{N}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\E}{\mathbb{E}}

\newtheorem{definition}{Definition}
\newtheorem{assumption}{Annahme}

\begin{document}

\maketitle

\section*{Projektüberblick}

\tableofcontents

\section{Zusammenfassung}

\section{Motivation und Fragestellung}

Während für Rekordfaktorisierungen mittlerweile ausschließlich das Zahlkörpersieb verwendet wird, bleibt Pollards Rho-Algorithmus einer schnellsten Algorithmen zur Faktorisierung von Zahlen bis ca. $2^{64}$. Da Leistungssteigerungen bei modernen Computern häufig durch verbesserete Nebenläufigkeit (z. B. durch mehr Prozessorkerne) erzielt werden, ist es eine interessante Frage, wie Pollards Rho-Methode am besten parallel ausgeführt werden kann. Bevor die Fragestellung präzise formuliert werden kann, soll jedoch Pollards Rho-Methode erklärt werden.

\subsection{Pollards Rho-Methode}

Sei $n$ die zu faktorisierende Zahl und $f : \Z/n\Z \to \Z/n\Z$ mit $f : x \mapsto x^{2k} + 1$ für einen Parameter $1 \le k \in \N$. Man wähle einen zufälligen Anfangswert $x_0 \in \Z/n\Z$ und betrachte die Folge $(x_n)_{n \in \N}$ definiert durch $x_n = f(x_{n - 1})$ für einen Parameter $1 \le k \in \N$. Da $(x_n)_{n \in \N}$ über der endlichen Menge $\Z/n\Z$ definiert ist, ist die Folge ab einem bestimmten Punkt periodisch. Sei $p$ ein Primfaktor von $n$ und $\pi : \Z/n\Z \to \Z/p\Z$ die natürliche Projektion. Die Idee von Pollards Rho-Algorithmus ist, zwei Folgenglieder $x_i, x_j \in \Z/n\Z$ zu finden, sodass $x_i \ne x_j$ aber $\pi(x_i) = \pi(x_j)$. Dann ist nämlich $\gcd(n, x_i - x_j)$ ein echter Faktor von $n$. Nimmt man nun heuristisch an, dass die Periodenlänge von $(x_n)_{n \in \N}$ in $\Z/n\Z$ deutlich länger als die Periodenlänge in $\Z/p\Z$ ist, reicht es aus, $x_i, x_j$ mit $i \ne j$ zu finden, die kongruent modulo $p$ sind. Diese Annahme begründet sich darin, dass für den kleinsten Primfaktor $p \le \sqrt n$ gilt. Zum Finden solcher $x_i, x_j$ betrachten wir den funktionalen Graphen von $\pi(f)$, wobei $\pi(f)$ die Abbildung $f$ betrachtet in $\Z/p\Z$ ist.

\begin{definition}[Funktionaler Graph]
    Sei $X$ eine endliche Menge und $f: X \to X$ eine Abbildung. Der funktionale Graph von $f$, geschrieben $\gamma(f)$, ist der gerichtete Graph mit Knotenmenge $X$ und Kantenmenge $E$, wobei die Kante $(x, y) \in X \times X$ genau dann in $E$ liegt, wenn $f(x) = y$.
\end{definition}

\noindent Es ist leicht zu zeigen, dass jede Zusammenhangskomponente eines funktionalen Graphen aus einem Zyklus und an den Zyklusknoten gewurzelten Bäumen besteht. In $\gamma(f)$ betrachtet startet $(x_n)_{n \in \N}$ mit $x_0$ in einem Baum und "`läuft"' durch den Graphen, wobei immer die eindeutige von einem Knoten ausgehende Kante entlanggegangen wird. An der Wurzel des Baums von $x_0$ wird der Zyklus in der Zusammenhangskomponente von $x_0$ betreten, und ab genau diesem Punkt ist $(x_n)_{n \in \N}$ periodisch. Um $x_i, x_j$ mit $i \ne j$ und $\pi(x_i) = \pi(x_j)$ zu finden, wird Floyds Algorithmus zum Finden des Zyklus in der Zusammenhangskomponente von $\pi(x_0)$ in $\gamma(\pi(f))$ verwendet. Floyds Algorithmus macht sich zunutze, dass es ein $r \in \N, 1 \le r \ge 1$ mit $\pi(x_r) = \pi(x_{2r})$ geben muss. Für das minimale solcher $r$ gilt außerdem $r \le \mu(f, x_0) + \lambda(f, x_0)$, wobei $\mu(f, x_0)$ die Höhe von $x_0$ in seinem Baum und $\lambda(f, x_0)$ die Länge des Zyklus ist (\cite{knu98}, S. 7). Wir nennen $\nu(f, x_0) = \mu(f, x_0) + \lambda(f, x_0)$ die Rho-Länge von $x_0$ in $f$. Indem man die Folgen $(x_n)_{n \in \N}$ und $(x_{2n})_{n \in \N}$ gleichzeitig Glied für Glied berechnet, stößt man in maximal $\nu(f, x_0)$ Schritten auf gewünschte $x_i, x_j$. Das Überprüfen in jedem Schritt, ob $\pi(x_i) = \pi(x_{2i})$ geschieht natürlich nicht explizit, da $p$ unbekannt ist, aber implizit durch Berechnung von $\gcd(n, x_i - x_{2i})$.

\begin{algorithm*}
    $x \gets $ zufällige natürliche Zahl zwischen $0$ und $n - 1$ \;
    $y \gets x$ \;
    \While{\emph{\sc{true}}}
    {
        $x \gets x^{2k} + 1 \mod n$ \;
        $y \gets (y^{2k} + 1)^{2k} + 1 \mod n$ \;
        $g \gets \gcd(n, x - y)$ \;
        \If{$g \ne 1 \text{\emph{\textbf{ and }}} g \ne n$}
        {
            \Return{$g$} \;
        }
    }

    \caption{Pollards Rho-Algorithmus}
\end{algorithm*}

\noindent Nun soll Pollards Rho-Algorithmus analysiert werden. Sei $\Z/p\Z^*$ die Gruppe der Einheiten in $\Z/p\Z$ und $g$ = $\gcd(p - 1, 2k)$. Man beobachte, dass $\psi : \Z/p\Z^\times \to \Z/p\Z^\times$ mit $\psi : x \mapsto x^{2k}$ ein Gruppenendomorphismus mit $[\Z/p\Z : \text{Im} f] = g$ ist. Daher haben genau $(p - 1) / g$ Knoten in $\gamma(f)$ Eingangsgrad $g$ und alle anderen Eingangsgrad 0. Knoten 1 als Einzelfall mit Eingangsgrad 1 ignorieren wir. Sei $A(n)$ die Menge der Abbildungen $\Z/n\Z \to \Z/n\Z$ und $A(n, g)$ die Teilmenge von $A(n)$, in der $(p - 1) / g$ Knoten Eingangsgrad $g$ und alle anderen Eingangsgrad 0 haben. Der Analyse der Rho-Methode liegen folgende Annhamen zugrunde:
\begin{itemize}
    \item[(A1)] Die Abbildung $f : x \mapsto x^{2k} + 1$ verhält sich bezüglich der Verteilung der Rho-Längen wie eine zufällig gewählte Abbildung aus $A(p, g)$.
    \item[(A2)] Die Abbildung $f : x \mapsto x^{2} + 1$ verhält sich bezüglich der Verteilung der Rho-Längen wie eine zufällig gewählte Abbildung aus $A(p)$.
    \item[(A3)] Die durchschnittliche Anzahl an Iterationen der while-Schleife ist $\overline \nu$, bis auf eine feste Konstante, wobei $\overline \nu$ der Mittelwert von $\nu(f, x_0)$ über alle Elemente von $A(p)$ und Startwerte $x_0 \in \Z/p\Z$ ist.
\end{itemize}
Diese Annahmen werden auch von \cite{pol75} und \cite{bp81} getroffen. Eine rigorose Analyse von Pollards Rho-Algorithmus ist nicht bekannt, die Annahmen lassen sich allerdings experimentell bestätigen. Für $k = 1$ ist damit die erwartete Anzahl an Iterationen der while-Schleife $\sqrt{\pi p / 2}$ (\cite{knu98}, S. 8). Da die Berechnung des größten gemeinsamen Teilers $O(\ln n)$ Schritte benötigt, ist die erwartete Laufzeit des Algorithmus $O(\sqrt p \ln n)$. Durch eine einfache Modifikation können die Kosten des $\gcd$ amortisiert werden, sodass sich die Laufzeit auf $O(\sqrt p)$ verringert (\cite{bre80}). Damit ist pro Iteration also nur noch die Zeit zur Berechnung der $2k$-ten Potenzen von $x$ und $y$ relevant, was durchschnittlich in $3/2 \lg 2k$ Schritten möglich ist. Mit $\lg x$ wird der Logarithmus zur Basis 2 bezeichnet. Der Faktor $3/2$ wird im Folgenden ignoriert, da er für den Vergleich verschiedener Werte für $k$ irrelevant ist. Die Anzahl an Iterationen der while-Schleife wird durch Veränderung von $k$ um einen Faktor $1/\sqrt{\gcd(p - 1, 2k) - 1}$ verringert (\cite{bp81}).

\subsection{Parallelisierung der Rho-Methode}

Sei $M$ die Anzahl verfügbarer Maschinen. Eine "`Maschine"'  meint hier nicht zwingend einen Computer, sondern eine Ressource, auf der ein sequentielles Programm ausgeführt werden kann, was beispielsweise auch ein Prozessorthread sein kann. Die Rho-Methode lässt sich parallelisieren, indem $M$ Anfangswerte unabhängig voneinander zufällig gewählt werden und auf jeder der $M$ Maschinen Pollards Rho-Algorithmus ausgeführt wird, bis eine der Maschinen einen Faktor findet. Nun ergibt sich folgende Frage, die in dieser Arbeit behandelt werden soll: \emph{Wie wählt man den Parameter $k$ für jede Maschine optimal, um eine möglichst geringe Laufzeit zu erzielen?} Vereinfachend wird nicht die Zeit betrachtet, die Floyds Algorithmus zum Finden eines Zyklus benötigt, sondern die Zeit, bis in der Folge $(x_n)_{n \in \N}$ eine Kollision auftritt, d.h. ein Wert erneut angenommen wird, der bereits angenommen wurde. Eine Zeiteinheit ist hier die Dauer einer Iteration im Fall $k = 1$, d.h. eine Maschine mit Paramter $k$ führt in $t$ Zeiteinheiten $\lfloor t / \lg 2k \rfloor$ Iterationen aus. Eine Zuordnung von $k$-Werten für $M$ Maschinen schreiben wir als Tupel $K = (k_1, k_2, \dots, k_M), 1 \le k_i \in \N$.  Wir bezeichnen mit $E(K)$ die erwartete Laufzeit des parallelen Pollard-Rho-Algorithmus mit $k$-Werten gegeben durch $K$. Mit (A1) und (A3) gilt also
\begin{align*}
    E(K) = \E \bigg ( \min_{i = 1}^M X_i \bigg )
\end{align*}
wobei $X_i$ die gleichverteilte Zufallsvariable über $A(p, \gcd(p - 1, 2k_i)) \times \Z/p\Z$ mit $X_i(f, x_0) = \nu(f, x_0)$ ist. Eine Schwierigkeit in der Herleitung einer Formel für $E(K)$ ist, dass die Rho-Längen der $i$-ten und $j$-ten Maschine nicht unabhängig sind, wenn $k_i = k_j$, da sich die $i$-te und $j$-te Maschine in diesem Fall im gleichen funktionalen Graphen bewegen. Wenn beispielsweise der Startwert der $i$-ten Maschine fixiert wird, ist bereits klar, dass die Rho-Länge der $j$-ten Maschine größer gleich der Rho-Länge der $i$-ten Maschine sein wird, wenn der Startwert ein Vorfahre des Startwerts der $i$-ten Maschine in einem Baum von $\gamma(f)$ ist. Daher werden im Folgenden die zwei Fälle abhängiger und unabhängiger Maschinen unterschieden.

\section{Eine Formel für den Fall unabhängiger Maschinen}

In diesem Abschnitt wird eine Formel für $E(K)$ hergleitet, die im Fall paarweise verschiedener $k$-Werte gilt. Für den Fall mehrerer Maschinen wird die Annahme getroffen, dass die Rho-Längen der $i$-ten und $j$-ten Maschine als Zufallsvariablen betrachtet stochastisch unabhängig sind, wenn $k_i \ne k_j$. Denn wenn $k_i \ne k_j$ und sich $x \mapsto x^{2k_i} + 1$ und $x \mapsto x^{2k_j} + 1$ bezüglich der Rho-Länge wie zufällig gewählte Abbildung verhalten, ist es vertretbar, die Unabhängigkeit der Rho-Längen anzunehmen.

Folgendes Argument basiert auf dem von \cite{bp81}, S. 627 -- 628, angepasst für mehrere Maschinen. Es wird die die Wahrscheinlichkeit betracht, dass nach genau $t$ Zeiteinheiten erstmalig eine Kollision bei einer Maschine auftritt. Die Wahrscheinlichkeit, dass im $i$-ten Schritt zu einem Vorgänger eines bereits besuchten Knotens gegangen wird (sodass im nächsten Schritt eine Kollision stattfände), ist $i \cdot (\gcd(p - 1, 2k) - 1)/(p - 1)$. Folglich ist die Wahrscheinlichkeit, dass bei einer Maschine mit Paramter $k$ nach $t$ Zeiteinheiten noch keine Kollision aufgetreten ist
\begin{align*}
    \prod_{j = 0}^{\lfloor t / \lg 2k \rfloor} \bigg (1 - \frac {j} {p / (\gcd(p - 1, 2k) - 1)} \bigg )
\end{align*}
Wir lassen im Folgenden die Gaußklammern weg, da sie asymptotisch nichts verändern und verwenden Taylors Näherung $1 + x \approx \exp x$ für $|x|$ klein. Sei $h_i = p / (\gcd(p - 1, 2k_i) - 1)$. Da in allen praktischen Fällen $h_i$ groß und $t$ deutlich kleiner als $p$ ist, ist die Wahrscheinlichkeit, dass nach genau $t$ Zeiteinheiten die erste Kollision auftritt
\begin{align*}
    \mathbb{P}_t
     & = \prod_{i = 1}^M \prod_{j = 0}^{t / \lg k_i - 1}
    \Bigg (1 - \frac {j} {h_i} \Bigg ) \cdot \Bigg (1 - \prod_{i = 1}^M \Bigg (1 - \frac {t / \lg 2k_i} {h_i} \Bigg ) \Bigg )                                                            \\
     & \approx \prod_{i = 1}^M \prod_{j = 0}^{t / \lg k_i - 1} \exp \Bigg ( \frac {-j}{h_i} \Bigg ) \cdot \Bigg (1 - \prod_{i = 1}^M \exp \Bigg (\frac {-t}{h_i \lg 2k_i} \Bigg )\Bigg ) \\
     & = \exp \Bigg ({- \sum_{i = 1}^M \sum_{j = 0}^{t/\lg 2k_i - 1} \frac j {h_i}} \Bigg ) \cdot \Bigg (1 - \exp \Bigg ( -\sum_{i = 1}^M \frac t {h_i \lg 2k_i} \Bigg ) \Bigg )         \\
     & \approx \exp \Bigg (- \sum_{i = 1}^M \frac {(t/\lg 2k_i)(t/\lg 2k_i - 1)} {2h_i} \Bigg ) \cdot t \cdot \Bigg (\sum_{i = 1}^M \frac 1 {h_i \lg 2k_i} \Bigg )                       \\
     & \approx \exp \Bigg (- \frac {t^2} 2 \sum_{i = 1}^M \frac 1 {h_i \lg^2 2k_i} \Bigg ) \cdot t \cdot \Bigg (\sum_{i = 1}^M \frac 1 {h_i \lg 2k_i} \Bigg )
\end{align*}
Um nun eine Formel für den Erwartungswert zu erhalten, wird $\sum_{a = 1}^p t \mathbb{P}_t$ durch $\int_{0}^\infty t \mathbb{P}_t \; dt$ angenähert, was wegen der schnellen Konvergenz von $e^{-t^2} \to 0$ wenn $t \to \infty$ vertetbar ist.
\begin{align}
    E(K)
     & = \Bigg ( \sum_{i = 1}^M \frac 1 {h_i \lg 2k_i} \Bigg ) \int_{0}^{\infty} t^2 \exp \Bigg (- \frac {t^2} 2 \sum_{i = 1}^M \frac 1 {h_i \lg^2 2k_i} \Bigg ) \nonumber \\
     & = \Bigg ( \sum_{i = 1}^M \frac 1 {h_i \lg 2k_i} \Bigg ) \sqrt {\pi/2} \Bigg (\sum_{i = 1}^M \frac 1 {h_i \lg^2 2k_i} \Bigg )^{-3/2}
\end{align}
Zur Auswertung des Integrals wurde die Tabelle in Wikipedia: \cite{gint} verwendet. Auch wenn die Herleitung aufgrund der vielen Näherungen krude scheint, erklärt sie gut das Laufzeitverhalten im Fall unabhängiger Maschinen. Setzt man $M = 1$ und $k_1 = 1$, erhält man $\sqrt{\pi p / 2}$, wie in \cite{pol75}.

\section{Die erwartete Rho-Länge in zufälligen Funktionen}

Um $E(K)$ zu bestimmen, wenn $k_i = k_j$ für $i \ne j$ gilt, muss die Abhängigkeit der Rho-Längen der $i$-ten und $j$-ten Maschinen berücksichtigt werden. Denn setzt man beispielsweise $M = 2$ und $k_1 = k_2 = 1$ in (1) ein, erhält man eine erwartete Laufzeit von $\sqrt {\pi p / 4}$. In diesem Abschnitt wird allerdings gezeigt, dass unter Berücksichtigung der Abhängigkeit $25/32 \cdot \sqrt{\pi p / 2}$ Schritte benötigt werden, und letzterer Wert wird von Experimenten unterstützt. Der Fall abhängiger Maschinen hat sich als weitaus schwieriger herausgestellt und es wurde keine allgemeine Formel gefunden. Jedoch konnte der Fall $M = 2, k_1 = k_2$ gelöst werden und einige Ideen für den Fall von beliebigem $M$ und $k_1 = k_2 = \dots = k_M$ entwickelt werden.

\subsection{Der Fall zweier Startpunkte}

Es soll nun $E(k_1, k_2)$ mit $k_1 = k_2$ bestimmt werden. Wir nehmen $k_1 = k_2 = 1$ an, denn wie bereits angemerkt, wird die Laufzeit

\subsection{Mögliche Methoden für den allgemeinen Fall}

\section{Bestimmung optimaler Exponenten für die Rho-Methode}

\subsection{Der Fall einer Maschine}

\subsection{Der Fall zweier Maschinen}

\section{Experimentelle Ergebnisse}\label{sec:ex}

\section{Fazit}

\printbibliography

\end{document}